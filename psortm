#!/usr/bin/perl
# Perl script wrapper to call psortm inside the docker container.
# Run this script using 'perl psortm [OPTIONS]'

use strict;
use Getopt::Long;
use File::Basename;
use Cwd 'abs_path';

our $cwd = abs_path 

sub main {

    my ($seqfile, $taxfile, $help, $outdir);
    my ($format, $verbose, $cutoff, $exact, $version, $output, $divergent);

    my @args = @ARGV;
    @args = remove_unneeded_args(\@args);
    my $my_args = join(" ".@args);

    GetOptions('seq|i=s'     => \$seqfile,  
               'tax|t=s'     => \$taxfile,
               'help|h'      => \$help,     'outdir|r=s'    => \$outdir,
               'format|f=s'  => \$format,   'divergent|d=f' => \$divergent,
               'verbose|v'   => \$verbose, 
               'cutoff|c=f'  => \$cutoff,   'output|o=s'    => \$output,
               'exact|e'     => \$exact,    'version'       => \$version);

    $seqfile = ans_path($seqfile);
    $taxfile = abs_path($taxfile);

    print "seqfile = $seqfile\n";
    print "taxfile = $taxfile\n";

    check_mandatory_field_values($seqfile, $taxfile, $outdir);

    $outdir =~ s/\/$//; # remove trailing slash if present

    my $symlink_seqfile_cmd = "ln -s $seqfile $outdir/";
    system($symlink_seqfile_cmd);
    die "Could not create symlink: $symlink_seqfile_cmd: $@\n" if $@;

    my $symlink_taxfile_cmd = "ln -s $taxfile $outdir/";
    system($symlink_taxfile_cmd);
    die "Could not create symlink: $symlink_taxfile_cmd: $@\n" if $@;

    my $seqfilename = basename($seqfile);
    my $taxfilename = basename($taxfile);

    my $cmd = "sudo docker run --rm -v $outdir:/tmp -e SEQFILE='/tmp/$seqfilename' -e TAXFILE='/tmp/$taxfilename' -ti psortm_commandline_docker:latest psortm $my_args";
    print "cmd = $cmd\n";
    system($cmd);
}

sub check_mandatory_field_values {

    my $ctr = 0;
    my @input_type = ("input sequence file (--seq)", "taxonomic classification file (--taxfile)", "results path (--outdir)");
    my $error = 0;
    foreach my $file_or_dir (@_) {
        if (!$file_or_dir) {
            print "hello1\n";
            $error = 1;
        } 
        elsif ((-f $file_or_dir) && (! -e $file_or_dir)) {
            print "hello2\n";
            $error = 1;
        }
        elsif (! -d $file_or_dir) {
            print "hello3\n";
            $error = 1;
        }

        if ($error) {
            print "No such file or directory: $file_or_dir\nPlease enter a valid location for your $input_type[$ctr]\n";
            usage();
            exit(0);
        }
        
        $ctr++;
    }
}

sub remove_unneeded_args {
    my $args = shift;

    #remove -d (output dir)
    my @modified_arg_list;
    for (my $i=0; $i<scalar(@$args); $i++) {
        if ($$args[$i] eq '-d') {
            $i++; # skip current and next element
        }
        else {
            push(@modified_arg_list, $$args[$i]);
        }
    }
}

sub usage {
    $0 =~ /^.*\/(.+)/;
    print("Usage: $1 -s <sequence file> -t <taxonomic classification file> [OPTIONS]\n");
    print("Example command: psortm -s myseqs.fasta -t mytax.csv\n");
    print("  --seqfile, -i     Input sequence file path (required)\n");
    print("  --taxfile, -t     A tab- or comma-delimited file of sequence ids with\n");
    print("                    their predicted taxonomic classifications (taxonomy ID\n");
    print("                    or taxonomic name). This can be generated using a program\n");
    print("                    such as MEGAN6 (required)\n");
    print("  --outdir, -r      Path of where to save results files.\n");
    print("  --cutoff, -c      Sets a cutoff value for reported results\n");
    print("  --divergent, -d   Sets a cutoff value for the multiple\n");
    print("                    localization flag\n");
    print("  --format, -f      Specifies sequence format (default is FASTA)\n");
    print("  --exact, -e       Skip SCLBLASTe (useful for batch runs of data\n");
    print("                    against itself in SCLBLAST)\n");
    print("  --output, -o      Specifies the format for the output (default is\n");
    print("                    'terse'  Value can be one of: terse or long\n");
    print("  --verbose, -v     Be verbose while running\n");
    print("  --version         Print the version of PSortb\n");
    print("  --help, -h        Displays usage information\n");
}

main();
